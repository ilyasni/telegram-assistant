<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Assistant ‚Äî QR –≤—Ö–æ–¥</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        :root {
            --tg-bg-color: #ffffff;
            --tg-text-color: #000000;
            --tg-button-color: #2481cc;
            --tg-button-text-color: #ffffff;
            --tg-hint-color: #999999;
            --tg-link-color: #2481cc;
            --tg-section-bg-color: #f8f8f8;
            --tg-header-bg-color: #ffffff;
            --tg-destructive-color: #ff3b30;
            --tg-accent-color: #2481cc;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --tg-bg-color: #17212b;
                --tg-text-color: #f5f5f5;
                --tg-button-color: #5288c1;
                --tg-button-text-color: #ffffff;
                --tg-hint-color: #708499;
                --tg-link-color: #6ab3f3;
                --tg-section-bg-color: #232e3c;
                --tg-header-bg-color: #17212b;
                --tg-destructive-color: #ec3942;
                --tg-accent-color: #6ab2f2;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--tg-bg-color);
            color: var(--tg-text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--tg-text-color);
        }

        .header p {
            font-size: 16px;
            color: var(--tg-hint-color);
        }

        .status {
            text-align: center;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 24px;
            font-weight: 500;
            transition: all 0.3s ease;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status.loading {
            background-color: var(--tg-section-bg-color);
            color: var(--tg-text-color);
        }

        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .qr-container {
            text-align: center;
            margin-bottom: 24px;
            min-height: 300px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .qr-container.show {
            opacity: 1;
            visibility: visible;
        }

        /* Context7: –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã–≤–∞–µ–º QR –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∫–æ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ñ–æ—Ä–º–∞ –ø–∞—Ä–æ–ª—è */
        .qr-container.hidden {
            display: none !important;
            min-height: 0 !important;
            margin-bottom: 0 !important;
        }

        .qr-code {
            background-color: var(--tg-section-bg-color);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px auto;
        }

        .qr-code img {
            width: 260px;
            height: 260px;
            border-radius: 8px;
            object-fit: contain;
        }

        .qr-code canvas {
            width: 260px;
            height: 260px;
            border-radius: 8px;
        }

        .qr-instructions {
            color: var(--tg-hint-color);
            font-size: 14px;
            margin-top: 12px;
        }

        .button {
            background-color: var(--tg-button-color);
            color: var(--tg-button-text-color);
            border: none;
            border-radius: 12px;
            padding: 16px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            margin-top: 16px;
            min-height: 56px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .button.show {
            opacity: 1;
            visibility: visible;
        }

        .button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .button:active {
            transform: translateY(0);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Context7: —Å—Ç–∏–ª–∏ –¥–ª—è —Ñ–æ—Ä–º—ã –≤–≤–æ–¥–∞ 2FA –ø–∞—Ä–æ–ª—è */
        .password-form {
            margin-top: 16px;
            padding: 16px;
            background-color: var(--tg-section-bg-color);
            border-radius: 12px;
            text-align: left;
            display: block;
            width: 100%;
            box-sizing: border-box;
        }

        .password-form h3 {
            margin-top: 0;
            margin-bottom: 16px;
            color: var(--tg-text-color);
            font-size: 18px;
            font-weight: 600;
        }

        .password-form p {
            color: var(--tg-hint-color);
            font-size: 14px;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .password-form input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--tg-section-bg-color);
            margin-bottom: 12px;
            font-size: 14px;
            background-color: var(--tg-bg-color);
            color: var(--tg-text-color);
            box-sizing: border-box;
        }

        .password-form input:focus {
            outline: none;
            border-color: var(--tg-accent-color);
        }

        .password-form button {
            width: 100%;
            margin-top: 0;
        }

        .password-form #password-error {
            margin-top: 12px;
            color: var(--tg-destructive-color);
            font-size: 14px;
            display: none;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }

            .header h1 {
                font-size: 20px;
            }

            .qr-code {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="qr-auth-section" class="container">
        <div class="header">
            <h1>üîê –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è</h1>
            <p>–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∏ –æ—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥</p>
        </div>

        <div id="status" class="status loading">
            –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...
        </div>

        <div id="qr-container" class="qr-container">
            <div class="qr-code" id="qr-code">
                <div style="color: var(--tg-hint-color); font-size: 16px;">–ó–∞–≥—Ä—É–∑–∫–∞ QR-–∫–æ–¥–∞...</div>
            </div>
            <div class="qr-instructions">
                –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤ Telegram
            </div>
        </div>

        <!-- Context7: –§–æ—Ä–º–∞ –¥–ª—è –≤–≤–æ–¥–∞ 2FA –ø–∞—Ä–æ–ª—è -->
        <div id="password-form" class="password-form hidden">
            <h3 style="margin-top: 0; margin-bottom: 12px; color: var(--tg-text-color);">üîê –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å 2FA</h3>
            <p style="color: var(--tg-hint-color); font-size: 14px; margin-bottom: 16px; line-height: 1.4;">
                –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Ö–æ–¥–∞
            </p>
            <input 
                type="password" 
                id="password-input" 
                placeholder="–ü–∞—Ä–æ–ª—å 2FA" 
                style="width: 100%; padding: 12px; border: 1px solid var(--tg-section-bg-color); border-radius: 8px; font-size: 14px; margin-bottom: 12px; background-color: var(--tg-section-bg-color); color: var(--tg-text-color);"
                autocomplete="current-password"
            />
            <button id="btn-submit-password" class="button show" style="margin-top: 0;">
                –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∞—Ä–æ–ª—å
            </button>
            <div id="password-error" style="margin-top: 12px; color: var(--tg-destructive-color); font-size: 14px; display: none;"></div>
        </div>

        <button id="cancel-btn" class="button" onclick="cancelAuth()">
            –û—Ç–º–µ–Ω–∏—Ç—å
        </button>
    </div>

    <script>
        (function() {
            'use strict';

            const API_BASE = (window.location.origin.includes('produman.studio') || window.location.origin.startsWith('https://produman.studio'))
                ? 'https://produman.studio'
                : '';
            const urlParams = new URLSearchParams(window.location.search);
            const fallbackToken = urlParams.get('token') || '';
            let sessionToken = null;
            let statusCheckInterval = null;
            let tenantId = null;
            let telegramUserId = null;
            let cachedInitData = '';
            let cachedInitDataUnsafe = null;
            let cachedAuthPayload = null;

            function getThemeColors() {
                if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.themeParams) {
                    const theme = window.Telegram.WebApp.themeParams;
                    return {
                        bgColor: theme.bg_color || '#ffffff',
                        textColor: theme.text_color || '#000000',
                        buttonColor: theme.button_color || '#2481cc',
                        buttonTextColor: theme.button_text_color || '#ffffff',
                        hintColor: theme.hint_color || '#999999',
                        linkColor: theme.link_color || '#2481cc',
                        sectionBgColor: theme.section_bg_color || '#f8f8f8',
                        headerBgColor: theme.header_bg_color || '#ffffff',
                        destructiveColor: theme.destructive_text_color || '#ff3b30',
                        accentColor: theme.accent_text_color || '#2481cc'
                    };
                }
                return null;
            }

            function applyTheme() {
                const theme = getThemeColors();
                if (theme) {
                    const root = document.documentElement;
                    root.style.setProperty('--tg-bg-color', theme.bgColor);
                    root.style.setProperty('--tg-text-color', theme.textColor);
                    root.style.setProperty('--tg-button-color', theme.buttonColor);
                    root.style.setProperty('--tg-button-text-color', theme.buttonTextColor);
                    root.style.setProperty('--tg-hint-color', theme.hintColor);
                    root.style.setProperty('--tg-link-color', theme.linkColor);
                    root.style.setProperty('--tg-section-bg-color', theme.sectionBgColor);
                    root.style.setProperty('--tg-header-bg-color', theme.headerBgColor);
                    root.style.setProperty('--tg-destructive-color', theme.destructiveColor);
                    root.style.setProperty('--tg-accent-color', theme.accentColor);
                }
            }

            function initTelegramWebApp() {
                if (window.Telegram && window.Telegram.WebApp) {
                    // Context7: –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ ready() - –±–∞–∑–æ–≤—ã–π –º–µ—Ç–æ–¥, –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—Å–µ–≥–¥–∞
                    if (typeof window.Telegram.WebApp.ready === 'function') {
                        window.Telegram.WebApp.ready();
                    }
                    
                    // Context7: –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ expand() - –±–∞–∑–æ–≤—ã–π –º–µ—Ç–æ–¥
                    if (typeof window.Telegram.WebApp.expand === 'function') {
                        window.Telegram.WebApp.expand();
                    }
                    
                    // Context7: setHeaderColor –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è –≤ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏—è—Ö
                    if (typeof window.Telegram.WebApp.setHeaderColor === 'function') {
                        try {
                            window.Telegram.WebApp.setHeaderColor('bg_color');
                        } catch (e) {
                            console.warn('[QR] setHeaderColor not supported:', e);
                        }
                    }
                    
                    // Context7: setBackgroundColor –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è –≤ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏—è—Ö
                    if (typeof window.Telegram.WebApp.setBackgroundColor === 'function') {
                        try {
                            window.Telegram.WebApp.setBackgroundColor('bg_color');
                        } catch (e) {
                            console.warn('[QR] setBackgroundColor not supported:', e);
                        }
                    }
                    
                    applyTheme();
                    
                    // Context7: onEvent –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è –≤ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏—è—Ö
                    if (typeof window.Telegram.WebApp.onEvent === 'function') {
                        try {
                            window.Telegram.WebApp.onEvent('themeChanged', applyTheme);
                        } catch (e) {
                            console.warn('[QR] onEvent not supported:', e);
                        }
                    }
                }
            }

            function getInitDataFromUrl() {
                try {
                    const searchParams = new URLSearchParams(window.location.search);
                    const tgParam = searchParams.get('tgWebAppData');
                    if (tgParam) {
                        const decoded = decodeURIComponent(tgParam);
                        if (decoded && decoded.includes('=')) {
                            console.log('[QR] initData extracted from URL search, length:', decoded.length);
                            return decoded;
                        }
                    }

                    if (window.location.hash && window.location.hash.includes('tgWebAppData=')) {
                        const hashParams = new URLSearchParams(window.location.hash.replace('#', ''));
                        const tgParamHash = hashParams.get('tgWebAppData');
                        if (tgParamHash) {
                            const decodedHash = decodeURIComponent(tgParamHash);
                            if (decodedHash && decodedHash.includes('=')) {
                                console.log('[QR] initData extracted from URL hash, length:', decodedHash.length);
                                return decodedHash;
                            }
                        }
                    }
                } catch (error) {
                    console.error('[QR] Failed to extract initData from URL:', error);
                }
                return '';
            }

            function sortObjectDeep(value) {
                if (Array.isArray(value)) {
                    return value.map(sortObjectDeep);
                }
                if (value && typeof value === 'object') {
                    const sorted = {};
                    Object.keys(value)
                        .sort()
                        .forEach((key) => {
                            sorted[key] = sortObjectDeep(value[key]);
                        });
                    return sorted;
                }
                return value;
            }

            function buildInitDataFromUnsafe(unsafe) {
                if (!unsafe || typeof unsafe !== 'object') {
                    return '';
                }
                const parts = [];
                Object.keys(unsafe).sort().forEach((key) => {
                    const value = unsafe[key];
                    if (value === undefined || value === null) {
                        return;
                    }
                    if (typeof value === 'object') {
                        parts.push(`${key}=${encodeURIComponent(JSON.stringify(sortObjectDeep(value)))}`);
                    } else {
                        parts.push(`${key}=${encodeURIComponent(String(value))}`);
                    }
                });
                if (parts.length === 0) {
                    return '';
                }
                return parts.join('&');
            }

            function isValidInitData(data) {
                if (!data || typeof data !== 'string') {
                    return false;
                }
                const trimmed = data.trim();
                if (trimmed.length === 0 || trimmed === '{}') {
                    return false;
                }
                return trimmed.includes('=');
            }

            function getInitData() {
                if (cachedInitData && isValidInitData(cachedInitData)) {
                    return cachedInitData;
                }

                const urlInitData = getInitDataFromUrl();
                if (isValidInitData(urlInitData)) {
                    cachedInitData = urlInitData;
                    return cachedInitData;
                }
                if (window.Telegram?.WebApp?.initData && isValidInitData(window.Telegram.WebApp.initData)) {
                    cachedInitData = window.Telegram.WebApp.initData;
                    return cachedInitData;
                }

                const unsafe = getInitDataUnsafe();
                if (unsafe) {
                    const built = buildInitDataFromUnsafe(unsafe);
                    if (isValidInitData(built)) {
                        cachedInitData = built;
                        console.log('[QR] Built initData from initDataUnsafe, length:', cachedInitData.length);
                        return cachedInitData;
                    }
                }

                return '';
            }

            async function waitForInitData(maxAttempts = 20, delayMs = 150) {
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const data = getInitData();
                    if (isValidInitData(data)) {
                        return data;
                    }
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
                return '';
            }

            function getInitDataUnsafe() {
                if (cachedInitDataUnsafe) {
                    return cachedInitDataUnsafe;
                }
                if (window.Telegram?.WebApp?.initDataUnsafe) {
                    cachedInitDataUnsafe = window.Telegram.WebApp.initDataUnsafe;
                    return cachedInitDataUnsafe;
                }
                return null;
            }

            function parseJWT(token) {
                if (!token) {
                    throw new Error('JWT token is empty');
                }
                const parts = token.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid token format');
                }
                let payloadBase64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');
                while (payloadBase64.length % 4) {
                    payloadBase64 += '=';
                }
                const decoded = atob(payloadBase64);
                return JSON.parse(decoded);
            }

            function extractContextFromInitData(initData) {
                const result = { userId: null, tenant: null };

                if (initData) {
                    try {
                        const params = new URLSearchParams(initData);
                        const userParam = params.get('user');
                        if (userParam) {
                            const userData = JSON.parse(decodeURIComponent(userParam));
                            if (userData?.id) {
                                console.log('[QR] telegram_user_id found (initData):', userData.id);
                                result.userId = userData.id;
                                result.tenant = String(userData.id);
                            }
                        }
                    } catch (error) {
                        console.error('[QR] Failed to parse initData:', error);
                    }
                }

                if (!result.userId) {
                    const unsafe = getInitDataUnsafe();
                    if (unsafe?.user?.id) {
                        console.log('[QR] telegram_user_id found (initDataUnsafe):', unsafe.user.id);
                        result.userId = unsafe.user.id;
                        result.tenant = String(unsafe.user.id);
                    }
                }

                return result;
            }

            async function resolveTenantContext() {
                if (tenantId) {
                    return tenantId;
                }

                const initData = getInitData();
                const extracted = extractContextFromInitData(initData);
                if (extracted.userId) {
                    telegramUserId = extracted.userId;
                }
                if (extracted.tenant) {
                    tenantId = extracted.tenant;
                    console.log('[QR] tenant_id extracted from initData / unsafe:', tenantId);
                    return tenantId;
                }

                if (!cachedAuthPayload && initData) {
                    try {
                        const authUrl = `${API_BASE || ''}/api/auth/telegram-webapp`;
                        const authResponse = await fetch(authUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ init_data: initData })
                        });
                        if (authResponse.ok) {
                            const authData = await authResponse.json();
                            try {
                                cachedAuthPayload = parseJWT(authData.access_token);
                                window.accessToken = authData.access_token;
                                if (!tenantId && cachedAuthPayload?.tenant_id) {
                                    tenantId = cachedAuthPayload.tenant_id;
                                    console.log('[QR] tenant_id extracted from JWT:', tenantId);
                                    return tenantId;
                                }
                                if (!telegramUserId && cachedAuthPayload?.sub) {
                                    telegramUserId = cachedAuthPayload.sub;
                                }
                            } catch (jwtError) {
                                console.error('[QR] Failed to parse JWT payload:', jwtError);
                            }
                        } else {
                            console.warn('[QR] /api/auth/telegram-webapp failed:', authResponse.status);
                        }
                    } catch (authError) {
                        console.error('[QR] Auth endpoint error:', authError);
                    }
                }

                if (initData) {
                    try {
                        const response = await fetch(`${API_BASE || ''}/tg/miniapp/init`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ init_data: initData })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data?.tenant_id) {
                                tenantId = data.tenant_id;
                                console.log('[QR] tenant_id received from /tg/miniapp/init:', tenantId);
                                return tenantId;
                            }
                        } else {
                            console.warn('[QR] /tg/miniapp/init failed:', response.status);
                        }
                    } catch (error) {
                        console.error('[QR] init endpoint error:', error);
                    }
                }

                if (!tenantId && telegramUserId) {
                    tenantId = String(telegramUserId);
                    console.log('[QR] Using telegram_user_id as tenant_id fallback:', tenantId);
                    return tenantId;
                }

                console.warn('[QR] tenant_id could not be resolved client-side');
                return null;
            }

            function updateStatus(message, type = 'loading') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            function showQR() {
                const qrContainer = document.getElementById('qr-container');
                if (qrContainer) {
                    // Context7: —É–±–∏—Ä–∞–µ–º hidden –∫–ª–∞—Å—Å –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º QR
                    qrContainer.classList.remove('hidden');
                    qrContainer.classList.add('show');
                }
                const cancelBtn = document.getElementById('cancel-btn');
                if (cancelBtn) {
                    cancelBtn.classList.add('show');
                }
            }

            function hideQR() {
                const qrContainer = document.getElementById('qr-container');
                if (qrContainer) {
                    qrContainer.classList.remove('show');
                    // Context7: –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã–≤–∞–µ–º QR –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —á—Ç–æ–±—ã –æ–Ω –Ω–µ –∑–∞–Ω–∏–º–∞–ª –º–µ—Å—Ç–æ
                    qrContainer.classList.add('hidden');
                }
                const cancelBtn = document.getElementById('cancel-btn');
                if (cancelBtn) {
                    cancelBtn.classList.remove('show');
                }
            }

            async function createSession() {
                try {
                    updateStatus('–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏...', 'loading');

                    const initData = await waitForInitData(30, 150);
                    const payload = {};

                    if (isValidInitData(initData)) {
                        cachedInitData = initData;
                        const resolvedTenantId = await resolveTenantContext();
                        payload.init_data = initData;
                        if (resolvedTenantId) {
                            payload.tenant_id = resolvedTenantId;
                        }
                    } else if (fallbackToken) {
                        console.warn('[QR] initData unavailable, using fallback token');
                        updateStatus('–ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π —Ç–æ–∫–µ–Ω...', 'loading');
                        payload.token = fallbackToken;
                    } else {
                        console.error('[QR] initData remains empty after waiting and no fallback token');
                        updateStatus('–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ Telegram WebApp. –û—Ç–∫—Ä–æ–π Mini App –∏–∑ Telegram.', 'error');
                        return;
                    }

                    const response = await fetch(`${API_BASE || ''}/tg/qr/start`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    sessionToken = data.session_token;

                    const url = new URL(location.href);
                    url.searchParams.set('session_id', sessionToken);
                    history.replaceState(null, '', url.toString());

                    if (data.qr_url) {
                        showQR();
                        renderQR(data.qr_url);
                        updateStatus('–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤ Telegram', 'loading');
                    } else {
                        updateStatus('–û–∂–∏–¥–∞–Ω–∏–µ QR-–∫–æ–¥–∞...', 'loading');
                    }

                    return data;
                } catch (error) {
                    console.error('[QR] Create session error:', error);
                    updateStatus(`–û—à–∏–±–∫–∞: ${error.message}`, 'error');
                    showDebugInfo({ reason: 'create_session_error' });
                    throw error;
                }
            }

            function renderQR(qrUrl) {
                const qrCodeDiv = document.getElementById('qr-code');

                const img = document.createElement('img');
                img.style.width = '260px';
                img.style.height = '260px';
                img.style.borderRadius = '8px';
                img.style.objectFit = 'contain';

                img.onload = () => {
                    console.log('[QR] QR Code loaded successfully');
                    qrCodeDiv.innerHTML = '';
                    qrCodeDiv.appendChild(img);
                };

                img.onerror = () => {
                    console.error('[QR] QR Code load failed');
                    qrCodeDiv.innerHTML = '<div style="color: var(--tg-destructive-color); font-size: 16px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ QR-–∫–æ–¥–∞</div>';
                };

                img.src = `${API_BASE}/tg/qr/png/${sessionToken}?t=${Date.now()}`;
            }

            async function checkStatus() {
                if (!sessionToken) return;

                try {
                    const response = await fetch(`${API_BASE}/tg/qr/status`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache'
                        },
                        body: JSON.stringify({ session_token: sessionToken })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    // Context7: –í–ê–ñ–ù–û! –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º password_required –ü–ï–†–í–´–ú
                    if (data.status === 'password_required') {
                        console.log('[QR] Password required detected, showing form');
                        // Context7: –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å, —Ç–∞–∫ –∫–∞–∫ –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–∂–µ –µ—Å—Ç—å –≤ —Ñ–æ—Ä–º–µ
                        hideQR();
                        
                        const passwordForm = document.getElementById('password-form');
                        const passwordInput = document.getElementById('password-input');
                        const passwordError = document.getElementById('password-error');
                        const cancelBtn = document.getElementById('cancel-btn');
                        
                        if (passwordForm) {
                            // Context7: –ª–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –î–û –ø–æ–∫–∞–∑–∞ —Ñ–æ—Ä–º—ã
                            const rectBefore = passwordForm.getBoundingClientRect();
                            console.log('[QR] Before showing form:', {
                                display: window.getComputedStyle(passwordForm).display,
                                visibility: window.getComputedStyle(passwordForm).visibility,
                                height: rectBefore.height,
                                width: rectBefore.width,
                                top: rectBefore.top,
                                left: rectBefore.left
                            });
                            
                            // Context7: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ñ–æ—Ä–º—É - —É–±–∏—Ä–∞–µ–º hidden –∫–ª–∞—Å—Å –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º display
                            passwordForm.classList.remove('hidden');
                            passwordForm.style.display = 'block';
                            passwordForm.style.visibility = 'visible';
                            passwordForm.style.opacity = '1';
                            
                            // Context7: —Å–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –æ—Ç–º–µ–Ω—ã
                            if (cancelBtn) {
                                cancelBtn.classList.remove('show');
                            }
                            
                            // Context7: –ª–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ü–û–°–õ–ï –ø–æ–∫–∞–∑–∞ —Ñ–æ—Ä–º—ã
                            setTimeout(() => {
                                const rectAfter = passwordForm.getBoundingClientRect();
                                console.log('[QR] After showing form:', {
                                    display: window.getComputedStyle(passwordForm).display,
                                    visibility: window.getComputedStyle(passwordForm).visibility,
                                    height: rectAfter.height,
                                    width: rectAfter.width,
                                    top: rectAfter.top,
                                    left: rectAfter.left,
                                    isVisible: rectAfter.height > 0 && rectAfter.width > 0
                                });
                                
                                // Context7: –µ—Å–ª–∏ —Ñ–æ—Ä–º–∞ –≤—Å–µ –µ—â–µ –Ω–µ –≤–∏–¥–Ω–∞, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∏–ª–∏
                                if (rectAfter.height === 0 || rectAfter.width === 0) {
                                    console.warn('[QR] Form has zero dimensions, forcing display');
                                    passwordForm.style.display = 'block';
                                    passwordForm.style.minHeight = '200px';
                                    passwordForm.style.position = 'relative';
                                }
                            }, 100);
                            
                            // –§–æ–∫—É—Å –Ω–∞ –ø–æ–ª–µ –≤–≤–æ–¥–∞
                            setTimeout(() => {
                                if (passwordInput) {
                                    passwordInput.focus();
                                }
                            }, 300);
                            
                            // Context7: –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ showAlert - –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è
                            if (window.Telegram?.WebApp && typeof window.Telegram.WebApp.showAlert === 'function') {
                                try {
                                    window.Telegram.WebApp.showAlert('–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å 2FA –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Ö–æ–¥–∞');
                                } catch (e) {
                                    console.warn('[QR] showAlert not supported:', e);
                                }
                            }
                        } else {
                            console.error('[QR] Password form not found!');
                            updateStatus('‚ùå –û—à–∏–±–∫–∞: —Ñ–æ—Ä–º–∞ –ø–∞—Ä–æ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error');
                        }
                        return; // –ù–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–ª—å—à–µ
                    }
                    
                    if (data.status === 'authorized') {
                        updateStatus('‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!', 'success');
                        hideQR();
                        document.getElementById('password-form').style.display = 'none';
                        clearInterval(statusCheckInterval);

                        setTimeout(() => {
                            // Context7: –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ close() - –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è
                            if (window.Telegram?.WebApp && typeof window.Telegram.WebApp.close === 'function') {
                                try {
                                    window.Telegram.WebApp.close();
                                } catch (e) {
                                    console.warn('[QR] close not supported:', e);
                                }
                            }
                        }, 2000);
                    } else if (data.status === 'failed') {
                        updateStatus(`‚ùå –û—à–∏–±–∫–∞: ${data.reason || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`, 'error');
                        hideQR();
                        document.getElementById('password-form').style.display = 'none';
                        clearInterval(statusCheckInterval);
                    } else if (data.status === 'expired') {
                        updateStatus('‚è∞ –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', 'error');
                        hideQR();
                        document.getElementById('password-form').style.display = 'none';
                        clearInterval(statusCheckInterval);
                    } else if (data.qr_url) {
                        showQR();
                        renderQR(data.qr_url);

                        if (data.status === 'awaiting_scan') {
                            updateStatus('–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤ Telegram', 'loading');
                        } else if (data.status === 'in_progress') {
                            updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Telegram...', 'loading');
                        } else {
                            updateStatus('–ì–æ—Ç–æ–≤–æ –∫ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—é', 'loading');
                        }
                    } else if (data.status === 'pending') {
                        updateStatus('–û–∂–∏–¥–∞–Ω–∏–µ QR-–∫–æ–¥–∞...', 'loading');
                    } else if (data.status === 'in_progress') {
                        updateStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Telegram...', 'loading');
                    }
                } catch (error) {
                    console.error('[QR] Status check error:', error);
                    updateStatus(`–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞: ${error.message}`, 'error');
                    clearInterval(statusCheckInterval);
                }
            }

            // Context7: —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ 2FA –ø–∞—Ä–æ–ª—è
            async function submitPassword() {
                const passwordInput = document.getElementById('password-input');
                const passwordError = document.getElementById('password-error');
                const btnSubmit = document.getElementById('btn-submit-password');
                
                const password = passwordInput.value.trim();
                if (!password) {
                    passwordError.textContent = '–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å';
                    passwordError.style.display = 'block';
                    return;
                }
                
                if (!sessionToken) {
                    passwordError.textContent = '–û—à–∏–±–∫–∞: —Å–µ—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞';
                    passwordError.style.display = 'block';
                    return;
                }
                
                try {
                    passwordError.style.display = 'none';
                    btnSubmit.disabled = true;
                    btnSubmit.textContent = '–û—Ç–ø—Ä–∞–≤–∫–∞...';
                    
                    const response = await fetch(`${API_BASE || ''}/tg/qr/password`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_token: sessionToken,
                            password: password
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∞—Ä–æ–ª—è' }));
                        throw new Error(errorData.detail || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∞—Ä–æ–ª—è');
                    }
                    
                    const data = await response.json();
                    console.log('[QR] Password submission response:', data);
                    
                    if (data.status === 'authorized') {
                        updateStatus('‚úÖ –ü–∞—Ä–æ–ª—å –ø—Ä–∏–Ω—è—Ç, –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏...', 'success');
                        document.getElementById('password-form').style.display = 'none';
                        
                        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å—Ç–∞—Ç—É—Å
                        if (!statusCheckInterval) {
                            statusCheckInterval = setInterval(checkStatus, 2000);
                        }
                    } else {
                        throw new Error(data.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
                    }
                } catch (error) {
                    console.error('[QR] Password submission error:', error);
                    
                    // Context7: –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–≤—è–∑–∞–Ω–∞ –ª–∏ –æ—à–∏–±–∫–∞ —Å WebAppMethodUnsupported
                    let errorMessage = error.message || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∞—Ä–æ–ª—è';
                    
                    // Context7: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫
                    if (errorMessage.includes('WebAppMethodUnsupported') || errorMessage.includes('MethodUnsupported')) {
                        console.warn('[QR] WebAppMethodUnsupported detected, this is a non-critical WebApp API error');
                        errorMessage = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∞—Ä–æ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.';
                    } else if (errorMessage.includes('internal error') || errorMessage.includes('server') || errorMessage.includes('500')) {
                        // Context7: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        errorMessage = '–í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥.';
                    } else if (errorMessage.includes('Invalid password') || errorMessage.includes('–Ω–µ–≤–µ—Ä–Ω—ã–π')) {
                        errorMessage = '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.';
                    } else if (errorMessage.includes('expired') || errorMessage.includes('–∏—Å—Ç–µ–∫')) {
                        errorMessage = '–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –ù–∞—á–Ω–∏—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.';
                    }
                    
                    passwordError.textContent = errorMessage;
                    passwordError.style.display = 'block';
                    passwordInput.value = '';
                    passwordInput.focus();
                } finally {
                    btnSubmit.disabled = false;
                    btnSubmit.textContent = '–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∞—Ä–æ–ª—å';
                }
            }

            async function cancelAuth() {
                if (sessionToken) {
                    try {
                        await fetch(`${API_BASE || ''}/tg/qr/cancel`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ session_token: sessionToken })
                        });
                    } catch (error) {
                        console.error('[QR] Cancel auth error:', error);
                    }
                }

                hideQR();
                document.getElementById('password-form').style.display = 'none';
                updateStatus('–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞', 'loading');
                clearInterval(statusCheckInterval);
            }

            document.addEventListener('DOMContentLoaded', async () => {
                initTelegramWebApp();

                // Context7: –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ isReady - –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å—Å—è
                if (window.Telegram && window.Telegram.WebApp) {
                    await new Promise(resolve => {
                        // Context7: isReady –º–æ–∂–µ—Ç –Ω–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –≤ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏—è—Ö
                        if (window.Telegram.WebApp.isReady !== undefined && window.Telegram.WebApp.isReady) {
                            resolve();
                        } else {
                            // Context7: –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ ready()
                            if (typeof window.Telegram.WebApp.ready === 'function') {
                                try {
                                    window.Telegram.WebApp.ready();
                                } catch (e) {
                                    console.warn('[QR] ready() error:', e);
                                }
                            }
                            setTimeout(resolve, 100);
                        }
                    });
                }

                // Context7: –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∞—Ä–æ–ª—è
                const btnSubmitPassword = document.getElementById('btn-submit-password');
                const passwordInput = document.getElementById('password-input');
                
                if (btnSubmitPassword) {
                    btnSubmitPassword.addEventListener('click', submitPassword);
                }
                
                if (passwordInput) {
                    passwordInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            submitPassword();
                        }
                    });
                }

                const urlParams = new URLSearchParams(location.search);
                const existingSessionId = urlParams.get('session_id');

                if (existingSessionId) {
                    sessionToken = existingSessionId;
                    updateStatus('–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Å—Å–∏–∏...', 'loading');
                    showQR();
                    statusCheckInterval = setInterval(checkStatus, 2000);
                } else {
                    try {
                        await createSession();
                        statusCheckInterval = setInterval(checkStatus, 2000);
                    } catch (error) {
                        console.error('[QR] Initialization error:', error);
                    }
                }
            });

            window.addEventListener('beforeunload', () => {
                if (statusCheckInterval) {
                    clearInterval(statusCheckInterval);
                }
            });

            window.cancelAuth = cancelAuth;
        })();
    </script>
</body>
</html>

