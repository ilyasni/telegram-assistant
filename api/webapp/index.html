<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Telegram Assistant - QR Login</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
      margin: 0; padding: 16px; background: #f8f9fa; 
    }
    .container { 
      max-width: 400px; margin: 0 auto; 
    }
    .card { 
      background: white; border-radius: 12px; padding: 24px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.1); 
      text-align: center;
    }
    .header {
      margin-bottom: 24px;
    }
    .title {
      font-size: 24px; font-weight: 600; color: #1a1a1a;
      margin: 0 0 8px 0;
    }
    .subtitle {
      color: #6b7280; font-size: 14px; margin: 0;
    }
    .status {
      padding: 12px 16px; border-radius: 8px; margin: 16px 0;
      font-weight: 500; font-size: 14px;
    }
    .status.loading { background: #fef3c7; color: #92400e; }
    .status.pending { background: #dbeafe; color: #1e40af; }
    .status.success { background: #d1fae5; color: #065f46; }
    .status.error { background: #fee2e2; color: #dc2626; }
    .qr-container {
      margin: 20px 0; padding: 20px; background: #f9fafb; border-radius: 8px;
    }
    #qr {
      display: flex; justify-content: center; align-items: center;
      min-height: 200px;
    }
    .timer {
      margin-top: 12px; font-size: 14px; color: #6b7280;
    }
    .timer.warning { color: #dc2626; font-weight: 500; }
    .instructions {
      margin-top: 20px; padding: 16px; background: #f3f4f6; border-radius: 8px;
      font-size: 14px; color: #374151; line-height: 1.5;
    }
    .btn {
      background: #3b82f6; color: white; border: none; border-radius: 8px;
      padding: 12px 24px; font-size: 14px; font-weight: 500;
      cursor: pointer; transition: background 0.2s;
    }
    .btn:hover { background: #2563eb; }
    .btn:disabled { background: #9ca3af; cursor: not-allowed; }
    .spinner {
      display: inline-block; width: 16px; height: 16px; border: 2px solid #f3f3f3;
      border-top: 2px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .hidden { display: none; }
    .error-details {
      margin-top: 12px; padding: 12px; background: #fef2f2; border: 1px solid #fecaca;
      border-radius: 6px; font-size: 12px; color: #dc2626; text-align: left;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <h1 class="title">üîê –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è</h1>
        <p class="subtitle">–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤ Telegram –¥–ª—è –≤—Ö–æ–¥–∞</p>
      </div>
      
      <div id="status" class="status loading">
        <span class="spinner"></span> –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...
      </div>
      
      <div id="qr-container" class="qr-container hidden">
        <div id="qr"></div>
        <div id="timer" class="timer"></div>
      </div>
      
      <div class="instructions">
        <strong>–ö–∞–∫ –≤–æ–π—Ç–∏:</strong><br>
        1. –û—Ç–∫—Ä–æ–π—Ç–µ Telegram –Ω–∞ –¥—Ä—É–≥–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ<br>
        2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞<br>
        3. –ù–∞–∂–º–∏—Ç–µ "–ü—Ä–∏–≤—è–∑–∞—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"<br>
        4. –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥
      </div>
      
      <button id="btn-retry" class="btn hidden">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å</button>
    </div>
  </div>

  <script>
    // DOM elements
    const statusEl = document.getElementById('status');
    const qrContainerEl = document.getElementById('qr-container');
    const qrEl = document.getElementById('qr');
    const timerEl = document.getElementById('timer');
    const btnRetryEl = document.getElementById('btn-retry');

    // State
    let sessionToken = null;
    let eventSource = null;
    let qrCode = null;
    let expiresAt = null;
    let countdownInterval = null;

    // API helper
    async function callApi(path, method = 'GET', body) {
      const headers = { 'Content-Type': 'application/json' };
      const options = { method, headers };
      if (body) options.body = JSON.stringify(body);
      const res = await fetch(path, options);
      if (!res.ok) throw new Error(await res.text());
      return await res.json();
    }

    // Update status display
    function updateStatus(text, type = 'loading') {
      statusEl.textContent = text;
      statusEl.className = `status ${type}`;
    }

    // Update timer
    function updateTimer() {
      if (!expiresAt) return;
      const now = Math.floor(Date.now() / 1000);
      const timeLeft = expiresAt - now;
      
      if (timeLeft <= 0) {
        timerEl.textContent = 'QR-–∫–æ–¥ –∏—Å—Ç—ë–∫';
        timerEl.className = 'timer warning';
        clearInterval(countdownInterval);
        if (eventSource) eventSource.close();
        updateStatus('QR-–∫–æ–¥ –∏—Å—Ç—ë–∫. –ù–∞–∂–º–∏—Ç–µ "–ü–æ–≤—Ç–æ—Ä–∏—Ç—å"', 'error');
        btnRetryEl.classList.remove('hidden');
        return;
      }
      
      const minutes = Math.floor(timeLeft / 60);
      const seconds = timeLeft % 60;
      const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      timerEl.textContent = `–î–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –µ—â—ë: ${timeStr}`;
      timerEl.className = timeLeft <= 60 ? 'timer warning' : 'timer';
    }

    // Start SSE connection
    function startSSE(token) {
      if (eventSource) {
        eventSource.close();
      }
      
      eventSource = new EventSource(`/tg/qr/sse?token=${encodeURIComponent(token)}`);
      
      eventSource.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          handleSSEMessage(data);
        } catch (e) {
          console.error('SSE parse error:', e);
        }
      };
      
      eventSource.onerror = function(err) {
        console.error('SSE error:', err);
        updateStatus('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑', 'error');
        btnRetryEl.classList.remove('hidden');
        if (eventSource) eventSource.close();
      };
    }

    // Handle SSE messages
    function handleSSEMessage(data) {
      console.log('SSE message:', data);
      
      // Context7 best practice: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º QR-–∫–æ–¥ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ qr_url –∏–ª–∏ —Å—Ç–∞—Ç—É—Å–µ awaiting_scan
      // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ QR-–∫–æ–¥–∞ –¥–∞–∂–µ –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–∏–ª—Å—è
      if (data.qr_url && !qrCode) {
        // Show QR code
        qrContainerEl.classList.remove('hidden');
        qrEl.innerHTML = '';
        qrCode = new QRCode(qrEl, {
          text: data.qr_url,
          width: 200,
          height: 200,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.H
        });
        updateStatus('–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤ Telegram', 'pending');
      }
      
      // Context7: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å "awaiting_scan" - QR-–∫–æ–¥ –≥–æ—Ç–æ–≤ –∫ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—é
      if (data.status === 'awaiting_scan' && data.qr_url && !qrCode) {
        qrContainerEl.classList.remove('hidden');
        qrEl.innerHTML = '';
        qrCode = new QRCode(qrEl, {
          text: data.qr_url,
          width: 200,
          height: 200,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.H
        });
        updateStatus('–û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –≤ Telegram', 'pending');
      }
      
      // Context7: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å "pending" - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É
      if (data.status === 'pending' && !data.qr_url) {
        updateStatus('–û–∂–∏–¥–∞–Ω–∏–µ QR-–∫–æ–¥–∞...', 'loading');
      }
      
      if (data.status === 'authorized') {
        updateStatus('‚úÖ –£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!', 'success');
        qrContainerEl.classList.add('hidden');
        if (eventSource) eventSource.close();
        if (countdownInterval) clearInterval(countdownInterval);
        
        // Close Mini App after success
        setTimeout(() => {
          if (window.Telegram?.WebApp?.close) {
            window.Telegram.WebApp.close();
          }
        }, 2000);
      } else if (data.status === 'failed') {
        updateStatus('‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏', 'error');
        btnRetryEl.classList.remove('hidden');
        if (eventSource) eventSource.close();
        if (countdownInterval) clearInterval(countdownInterval);
      }
    }

    // Start QR login process
    async function startQRLogin() {
      try {
        updateStatus('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...', 'loading');
        btnRetryEl.classList.add('hidden');
        
        // Get initData from Telegram WebApp
        // Context7: –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ initData
        let initData = '';
        if (window.Telegram?.WebApp?.initData) {
          initData = window.Telegram.WebApp.initData;
          console.log('initData from Telegram.WebApp.initData, length:', initData.length);
        } else if (window.Telegram?.WebApp?.initDataUnsafe) {
          // Fallback –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –≤–µ—Ä—Å–∏–π Telegram WebApp
          console.log('Using initDataUnsafe as fallback');
          initData = JSON.stringify(window.Telegram.WebApp.initDataUnsafe);
        } else {
          console.error('initData NOT FOUND! window.Telegram:', !!window.Telegram, 
                       'WebApp:', !!window.Telegram?.WebApp,
                       'initData:', !!window.Telegram?.WebApp?.initData);
          updateStatus('–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ Telegram WebApp', 'error');
          btnRetryEl.classList.remove('hidden');
          return;
        }
        
        if (!initData || initData.length === 0) {
          console.error('initData is empty!');
          updateStatus('–û—à–∏–±–∫–∞: –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ Telegram WebApp', 'error');
          btnRetryEl.classList.remove('hidden');
          return;
        }
        
        console.log('initData extracted, length:', initData.length, 'first 50 chars:', initData.substring(0, 50));
        
        // Context7: –ò–∑–≤–ª–µ–∫–∞–µ–º telegram_user_id –∏ tenant_id –∏–∑ initData
        let telegramUserId = null;
        let tenantId = null;
        if (initData) {
          try {
            // –ü–∞—Ä—Å–∏–º initData –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è user_id
            const params = new URLSearchParams(initData);
            const userParam = params.get('user');
            if (userParam) {
              const userData = JSON.parse(decodeURIComponent(userParam));
              telegramUserId = userData.id;
              console.log('Extracted telegram_user_id:', telegramUserId);
              // Context7: –¥–ª—è –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º telegram_id –∫–∞–∫ tenant_id
              // –í –±—É–¥—É—â–µ–º tenant_id –±—É–¥–µ—Ç –∏–∑–≤–ª–µ–∫–∞—Ç—å—Å—è –∏–∑ –ë–î —á–µ—Ä–µ–∑ /tg/miniapp/init
              tenantId = String(telegramUserId);
            }
          } catch (e) {
            console.error('Failed to parse initData:', e);
          }
        }
        
        // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∏–∑ initData, –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ /tg/miniapp/init
        if (!tenantId) {
          const initResponse = await callApi('/tg/miniapp/init', 'POST', { init_data: initData });
          console.log('init response:', initResponse);
          // TODO: extract tenant_id from initResponse if available
        }
        
        // Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º telegram_user_id –∫–∞–∫ tenant_id –¥–ª—è –Ω–æ–≤—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        if (!tenantId && telegramUserId) {
          tenantId = String(telegramUserId);
          console.log('Using telegram_user_id as tenant_id:', tenantId);
        }
        
        if (!tenantId) {
          throw new Error('Cannot determine tenant_id from initData');
        }
        
        // Link Mini App
        const linkResponse = await callApi('/tg/miniapp/link', 'POST', { 
          start_param: 'qr_login', 
          tenant_id: tenantId 
        });
        sessionToken = linkResponse.session_token;
        console.log('session_token:', sessionToken.substring(0, 24) + '...');
        
        // Start QR session
        // Context7 best practice: –ø–µ—Ä–µ–¥–∞–µ–º initData –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è telegram_user_id
        const qrStartPayload = { 
          tenant_id: tenantId,
          invite_code: 'DEMO123', // TODO: get from URL params or initData
        };
        
        // Context7: –í–ê–ñ–ù–û - –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–µ–¥–∞–µ–º init_data –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
        if (initData && initData.length > 0) {
          qrStartPayload.init_data = initData;
          console.log('Sending init_data to /tg/qr/start, length:', initData.length);
        } else {
          console.error('WARNING: initData is empty, will not send to /tg/qr/start!');
        }
        
        console.log('QR start payload:', { ...qrStartPayload, init_data: qrStartPayload.init_data ? `[${qrStartPayload.init_data.length} chars]` : 'missing' });
        const startResponse = await callApi('/tg/qr/start', 'POST', qrStartPayload);
        console.log('qr start response:', startResponse);
        
        // Parse expiration time
        if (startResponse.expires_at) {
          expiresAt = Math.floor(new Date(startResponse.expires_at).getTime() / 1000);
          countdownInterval = setInterval(updateTimer, 1000);
          updateTimer();
        }
        
        // Start SSE for real-time updates
        startSSE(sessionToken);
        
      } catch (error) {
        console.error('QR login error:', error);
        updateStatus('–û—à–∏–±–∫–∞: ' + error.message, 'error');
        btnRetryEl.classList.remove('hidden');
      }
    }

    // Retry button handler
    btnRetryEl.addEventListener('click', () => {
      startQRLogin();
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      startQRLogin();
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (eventSource) eventSource.close();
      if (countdownInterval) clearInterval(countdownInterval);
    });
  </script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
</body>
</html>
